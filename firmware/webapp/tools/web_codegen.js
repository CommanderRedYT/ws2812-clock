#!/usr/bin/env node
import fs from 'fs';
import path from 'path';
import process from 'process';
import { minify } from 'minify';
import { gzip } from 'node-gzip';
import mime from 'mime-types';
import extraDependencies from "./dependencies.js";

// cwd /path/to/ws2812-clock/firmware
// generated .h file: /path/to/ws2812-clock/firmware/main/communication/webserver_files.h
// files to include: /path/to/ws2812-clock/firmware/webapp/src/* (html, js, css, ...)

if (!process.cwd().endsWith('firmware')) {
    console.error('Please run this script from the firmware/ directory');
    process.exit(1);
}

const srcDir = path.join(process.cwd(), 'webapp', 'src');
const hFilePath = path.join(process.cwd(), 'main', 'communication', 'webserver_files.h');

fs.writeFileSync(hFilePath, '');

async function* getFiles(dir) {
    const dirents = await fs.promises.readdir(dir, { withFileTypes: true });
    for (const dirent of dirents) {
        const res = path.resolve(dir, dirent.name);
        if (dirent.isDirectory()) {
            yield* getFiles(res);
        } else {
            yield res;
        }
    }
}

const TEMPLATE_H_START = `#pragma once
// This file is autogenerated by web_codegen.js
// Do not edit this file manually

// system includes
#include <cstdint>

// esp-idf includes
#include <esp_http_server.h>

// 3rdparty lib includes
#include <makearray.h>

// local includes
#include "webserver_frontend.h"

namespace webserver::webserver_files {
`;

const TEMPLATE_H_FILE = `
constexpr const int {{name}}_size = {{size}};
constexpr const uint8_t {{name}}[] = {
{{data}}
};
constexpr const char {{name}}_mime[] = "{{mime}}";

esp_err_t {{name}}_handler(httpd_req_t *req)
{
    static_assert({{name}}_size > 0, "Invalid {{name}}_size");
    static_assert({{name}}_mime[0] != '\\0', "Invalid {{name}}_mime");
    static_assert(sizeof({{name}}) == {{name}}_size, "Invalid {{name}}_size");
    httpd_resp_set_type(req, {{name}}_mime);
    httpd_resp_set_hdr(req, "Content-Encoding", "gzip");
    httpd_resp_set_hdr(req, "Cache-Control", "max-age=86400"); // 1 day
    httpd_resp_send(req, reinterpret_cast<const char*>({{name}}), {{name}}_size);
    return ESP_OK;
}
`;

const TEMPLATE_H_FILE_REGISTER_WEBAPP_START = `

auto get_handlers()
{
    return cpputils::make_array(
`;

const TEMPLATE_H_FILE_REGISTER_WEBAPP = `        httpd_uri_t{ .uri = "/{{original_name}}", .method = HTTP_GET, .handler = {{name}}_handler, .user_ctx = nullptr },\n`;

const TEMPLATE_H_FILE_REGISTER_WEBAPP_END = `
        // httpd_uri_t{ .uri = "/", .method = HTTP_GET, .handler = captive_portal_handler, .user_ctx = (void*)&index_html_handler }
        httpd_uri_t{ .uri = "/", .method = HTTP_GET, .handler = index_html_handler, .user_ctx = nullptr }
    );
}
`;

const TEMPLATE_H_END = `
[[maybe_unused]] constexpr const auto TOTAL_SIZE = {{total_size}};
} // namespace webserver::webserver_files
`;

async function main() {
    let totalSize = 0;

    fs.writeFileSync(hFilePath, TEMPLATE_H_START);

    let handlerList = TEMPLATE_H_FILE_REGISTER_WEBAPP_START;

    const compile = async (srcFile) => {
        console.log(`Compiling ${srcFile}`);
        let overrideName = null;
        let skipMinify = false;

        if (Array.isArray(srcFile)) {
            overrideName = srcFile[1];
            srcFile = srcFile[0];
            skipMinify = true;
        }

        // check if file is empty
        if ((await fs.promises.readFile(srcFile, 'utf8')) === '') {
            console.warn(`Skipping ${srcFile} because it is empty`);
            return;
        }

        const extention = path.extname(srcFile);

        if (!['.html', '.js', '.css'].includes(extention)) {
            skipMinify = true;
            console.warn(`Skip minify for ${srcFile} because it is not a html, js or css file`);
        }

        const minified = skipMinify ?
            await fs.promises.readFile(srcFile) :
            await minify(srcFile, {sourceMap: false, html: { removeScriptTypeAttributes: false, removeRedundantAttributes: false }});

        // create gzip file
        const compressed = await gzip(minified); // compressed is a Buffer

        const name = path
            .relative(srcDir, srcFile)
            .replace(/[^a-z0-9]/gi, '_')
            .replace(/_+/g, '_')

        let data = '    ';

        for (let i = 0; i < compressed.length; i++) {
            data += `0x${compressed[i].toString(16).padStart(2, '0')}, `;
            if (i % 16 === 15) {
                data += '\n    ';
            }
        }

        const size = compressed.length;

        const mimeType = mime.lookup(srcFile) || 'text/plain';

        if (size < 50) {
            console.log(minified);
        }

        totalSize += size;

        const hFile = TEMPLATE_H_FILE
            .replaceAll('{{name}}', name)
            .replaceAll('{{size}}', ''+size)
            .replaceAll('{{data}}', data)
            .replaceAll('{{mime}}', mimeType);

        fs.appendFileSync(hFilePath, hFile);

        handlerList += TEMPLATE_H_FILE_REGISTER_WEBAPP
            .replaceAll('{{name}}', name)
            .replaceAll('{{original_name}}',
                overrideName === null ?
                    path.relative(srcDir, srcFile) :
                    overrideName
            );
    };

    for await (const srcFile of getFiles(srcDir)) {
        await compile(srcFile);
    }

    for (const extraDependency of extraDependencies.map(dep => {
        const newDep = [...dep];
        newDep[0] = path.join(process.cwd(), 'webapp', newDep[0]);
        return newDep;
    })) {
        await compile(extraDependency);
    }

    handlerList += TEMPLATE_H_FILE_REGISTER_WEBAPP_END;

    fs.appendFileSync(hFilePath, handlerList);

    fs.appendFileSync(hFilePath, TEMPLATE_H_END.replaceAll('{{total_size}}', ''+totalSize));
}

main();
